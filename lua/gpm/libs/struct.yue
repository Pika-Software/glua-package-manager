--[[

    Copyright © 2011-2020 Rebecca "ToxicFrog" Kelly
    FP module copyright © 2008 Peter "Corsix" Cawley

    Permission is hereby granted, free of charge, to any person obtaining a copy of
    this software and associated documentation files (the "Software"), to deal in
    the Software without restriction, including without limitation the rights to
    use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
    the Software, and to permit persons to whom the Software is furnished to do so,
    subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
    FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
    COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
    IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    Modified by: Pika Software

--]]

_G = _G
import error, type from _G
import environment from _G.gpm
import string, math, table, tonumber, assert, ArgAssert, isstring, isnumber from environment
import char, byte, len, sub, format, match, find, rep from string
import trunc, floor, min, max, pow2, mod2 from math
import concat, unpack from table
luaClass = environment.class

registry = {}
_module_0 = { :registry }

-- https://github.com/ToxicFrog/vstruct/blob/master/cursor.lua
_module_0.Cursor = luaClass( "Cursor", {
    __tostring: =>
        return format( "Cursor: %p [%d/%d]", @, @position, @size )

    new: ( @data = "" ) =>
        assert( isstring( data ), "data must be a string" )
        @size = len( data )
        @position = 0
        @buffer = {}

    Flush: =>
        :buffer = @

        length = #buffer
        if length == 0
            return

        :data, :position, :size = @

        if position > size
            data ..= rep( "\0", position - size )
            size = len( data )

        content = concat( buffer, "", 1, length )

        for index = 1, length
            buffer[ index ] = nil

        length = len( content )
        data = sub( data, 1, position ) .. content .. sub( data, position + length + 1, size )
        @position = position + length
        @data, @size = data, len( data )

    Seek: ( whence = "cur", offset = 0 ) =>
        @Flush!

        :position, :size = @

        switch whence
            when "cur"
                position += offset

            when "end"
                position = size + offset

            when "set"
                position = offset

            else
                error "bad argument #1 to 'Seek' (invalid option)", 2
                return nil

        position = @position = min( max( position, 0 ), size )
        return position

    Write: ( str ) =>
        @buffer[] = str

    Read: ( length = 1 ) =>
        @Flush!

        :position, :size = @

        if position > size
            return nil, "eof"

        if length == "*a"
            length = size

        @position = min( position + length, size )
        return sub( @data, position + 1, position + length )
} )

-- https://github.com/ToxicFrog/vstruct/blob/master/init.lua
explode = _module_0.explode = ( number, size = 0 ) ->
    mask, length = {}, 0
    while number ~= 0 or length < size
        length += 1
        mask[ length ] = mod2[ number ] ~= 0
        number = trunc( number / 2 )

    return mask

implode = _module_0.implode = ( mask, size, offset ) ->
    size = size or #mask

    byte0 = 0
    if offset
        for index = size, 1, -1
            byte0 = byte0 * 2 + ( mask[ index + offset ] and 1 or 0 )

        return byte0

    for index = size, 1, -1
        byte0 = byte0 * 2 + ( mask[ index ] and 1 or 0 )

    return byte0

-- https://github.com/ToxicFrog/vstruct/blob/master/io.lua
io = _module_0.io = {}

local endianness
do

    import isint, isuint from math

    local registerIO, defaultTypeSize, defaultSize
    do

        defaultTypeSize = ( number ) ->
            assert( number, "format requires a size" )
            return tonumber( number )

        defaultSize = ( str ) ->
            assert( str, "format requires a size" )
            return nil

        defaultValidate = ->
            return true

        _base_0 = {
            __index: {
                Size: defaultSize

                Validate: defaultValidate

                HasValue: ->
                    return false
            }
        }

        _base_1 = {
            __index: {
                Size: defaultTypeSize
                Validate: defaultValidate

                HasValue: ->
                    return true
            }
        }

        registerIO = _module_0.RegisterIO = ( name, tbl, isType ) ->
            io[ name ] = setmetatable( tbl, isType and _base_1 or _base_0 )

    setAlias = _module_0.SetIOAlias = ( name, symbol ) ->
        io[ symbol ] = io[ name ]

    do

        read = ( fileDescriptor, _, offset ) ->
            assert( fileDescriptor\Seek( "cur", offset ) )
            return nil

        registerIO( "+", {
            Read: read
            Write: read
        } )

    do

        read = ( fileDescriptor, _, offset ) ->
            assert( fileDescriptor\Seek( "cur", -offset ) )
            return nil

        registerIO( "-", {
            Read: read
            Write: read
        } )

    do

        read = ( fileDescriptor, _, offset ) ->
            assert( fileDescriptor\Seek( "set", offset ) )
            return nil

        registerIO( "@", {
            Read: read
            Write: read
        } )

    do

        local value

        big = ->
            value = endianness.value = "big"
            return value

        little = ->
            value = endianness.value = "little"
            return value

        host = ->
            if isBig
                return big!

            return little!

        isBig = byte( string.dump( environment.debug.fempty ), 7 ) == 0x00

        endianness = {
            value: nil

            Big: big
            Little: little
            Size: defaultTypeSize

            Host: host

            Get: ->
                return value

            Set: ( value ) ->
                return switch value
                    when "big"
                        big!

                    when "little"
                        little!

                    else
                        host!

        }

        registerIO( "endianness", endianness )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io.lua
    do

        -- big-endian
        do

            import Big from endianness

            read = ->
                Big!
                return nil

            registerIO( ">", {
                Size: ( number ) ->
                    assert( number == nil, "'>' is an endianness control, and does not have size" )
                    return 0

                Read: read
                Write: read
            } )

        -- little-endian
        do

            import Little from endianness

            read = ->
                Little!
                return nil

            registerIO( "<", {
                Size: ( number ) ->
                    assert( number == nil, "'<' is an endianness control, and does not have size" )
                    return 0

                Read: read
                Write: read
            } )

        -- host
        do

            import Host from endianness

            read = ->
                Host!
                return nil

            registerIO( "=", {
                Size: ( number ) ->
                    assert( number == nil, "'=' is an endianness control, and does not have size" )
                    return 0

                Read: read
                Write: read
            } )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/a.lua
    -- align-to
    do

        read = ( fileDescriptor, _, align ) ->
            :position = fileDescriptor
            if position % align ~= 0
                fileDescriptor\Seek( "cur", align - ( position % align ) )

        registerIO( "a", {
            Read: read
            Write: read
        } )

    local readUInt, writeUInt
    do

        -- https://github.com/ToxicFrog/vstruct/blob/master/io/u.lua
        -- unsigned ints
        readUInt = ( _, binary, bytes = 4 ) ->
            number = 0

            if endianness.value == "big"
                for index = 1, bytes, 1
                    number = number * 0x100 + byte( binary, index, index )

                return number

            for index = bytes, 1, -1
                number = number * 0x100 + byte( binary, index, index )

            return number

        writeUInt = ( _, number, bytes = 4 ) ->
            assert( number >= 0 and number < pow2[ bytes * 8 ], "unsigned integer overflow" )
            number = trunc( number )
            buffer = {}

            if endianness.value == "big"
                for index = bytes, 1, -1
                    buffer[ index ] = char( number % 0x100 )
                    number = trunc( number / 0x100 )

                return concat( buffer, "", 1, bytes )

            for index = 1, bytes, 1
                buffer[ index ] = char( number % 0x100 )
                number = trunc( number / 0x100 )

            return concat( buffer, "", 1, bytes )

        readUIntBits = ( readBit, size ) ->
            bits = 0
            for _ = 1, ( size or 4 )
                bits = bits * 2 + readBit!

            return bits

        writeUIntBits = ( writeBit, data, size ) ->
            for index = ( size or 4 ) - 1, 0, -1
                writeBit( mod2[ floor( data / pow2[ index ] ) ] )

        size = ( number = 4 ) ->
            assert( isnumber( number ), "unsigned integer size must be a number" )
            return number

        registerIO( "I", {
            Size: size
            Read: readUInt
            ReadBits: readUIntBits
            Write: writeUInt
            WriteBits: writeUIntBits
        }, true )

        setAlias( "I", "u" )

        registerIO( "H", {
            Size: ->
                return 2

            Read: ( _, binary ) ->
                return readUInt( nil, binary, 2 )

            Write: ( _, number ) ->
                return writeUInt( nil, number, 2 )

            ReadBits: ( readBit ) ->
                return readUIntBits( readBit, 2 )

            WriteBits: ( writeBit, number ) ->
                return writeUIntBits( writeBit, number, 2 )

        }, true )

        readInt = ( _, binary, bytes = 4 ) ->
            number = readUInt( nil, binary, bytes )
            if number < pow2[ bytes * 8 - 1 ]
                return number

            return number - pow2[ bytes * 8 ]

        writeInt = ( _, number, bytes = 4 ) ->
            limit = pow2[ bytes * 8 - 1 ]
            assert( number >= -limit and number < limit, "signed integer overflow" )
            number = trunc( number )

            if number < 0
                number += pow2[ bytes * 8 ]

            return writeUInt( nil, number, bytes )

        readIntBits = ( readBit, size = 4 ) ->
            number = readUIntBits( readBit, size )
            if number < pow2[ size - 1 ]
                return number

            return number - pow2[ size ]

        writeIntBits = ( writeBit, number, size = 4 ) ->
            if number < 0
                number += pow2[ size ]

            return writeUIntBits( writeBit, number, size )

        -- https://github.com/ToxicFrog/vstruct/blob/master/io/i.lua
        -- signed integers
        registerIO( "i", {
            Size: size
            Read: readInt
            ReadBits: readIntBits
            Write: writeInt
            WriteBits: writeIntBits
        }, true )

        registerIO( "h", {
            Size: ->
                return 2

            Read: ( _, binary ) ->
                return readInt( nil, binary, 2 )

            Write: ( _, number ) ->
                return writeInt( nil, number, 2 )

            ReadBits: ( readBit ) ->
                return readIntBits( readBit, 2 )

            WriteBits: ( writeBit, data ) ->
                return writeIntBits( writeBit, data, 2 )

        }, true )

        registerIO( "T", {
            Size: ->
                return 4

            Read: ( _, binary ) ->
                return readUInt( nil, binary, 4 )

            Write: ( _, number ) ->
                return writeUInt( nil, number, 4 )

            ReadBits: ( readBit ) ->
                return readUIntBits( readBit, 4 )

            WriteBits: ( writeBit, data ) ->
                return writeUIntBits( writeBit, data, 4 )

        }, true )

        registerIO( "l", {
            Size: ->
                return 8

            Read: ( _, binary ) ->
                return readInt( nil, binary, 8 )

            Write: ( _, number ) ->
                return writeInt( nil, number, 8 )

            ReadBits: ( readBit ) ->
                return readIntBits( readBit, 8 )

            WriteBits: ( writeBit, data ) ->
                return writeIntBits( writeBit, data, 8 )

        }, true )

        setAlias( "l", "j" )

        registerIO( "L", {
            Size: ->
                return 8

            Read: ( _, binary ) ->
                return readUInt( nil, binary, 8 )

            Write: ( _, number ) ->
                return writeUInt( nil, number, 8 )

            ReadBits: ( readBit ) ->
                return readUIntBits( readBit, 8 )

            WriteBits: ( writeBit, data ) ->
                return writeUIntBits( writeBit, data, 8 )

        }, true )

        setAlias( "L", "J" )

        -- https://github.com/ToxicFrog/vstruct/blob/master/io/p.lua
        -- signed fixed point
        -- format is pTOTAL_SIZE,FRACTIONAL_SIZE
        -- Fractional size is in bits, total size in bytes.
        registerIO( "p", {
            Size: ( size, fraction ) ->
                assert( size, "format requires a size" )
                assert( fraction, "format requires a fractional-part size" )

                if tonumber( size ) and tonumber( fraction )
                    -- Check only possible if both values were specified at compile time
                    assert( size * 8 >= fraction, "fixed point number has more fractional bits than total bits" )

                return size

            Read: ( _, binary, size, fraction ) ->
                return readInt( nil, binary, size ) / pow2[ fraction ]

            Write: ( _, number, size, fraction ) ->
                return writeInt( nil, number * pow2[ fraction ], size )

        }, true )

        -- https://github.com/ToxicFrog/vstruct/blob/master/io/pu.lua
        -- signed fixed point
        -- format is pTOTAL_SIZE,FRACTIONAL_SIZE
        -- Fractional size is in bits, total size in bytes.
        registerIO( "pu", {
            Size: ( size, fraction ) ->
                assert( size, "format requires a size" )
                assert( fraction, "format requires a fractional-part size" )

                if tonumber( size ) and tonumber( fraction )
                    -- Check only possible if both values were specified at compile time
                    assert( size * 8 >= fraction, "fixed point number has more fractional bits than total bits" )

                return size

            Read: ( _, binary, size, fraction ) ->
                return readUInt( nil, binary, size ) / pow2[ fraction ]

            Write: ( _, number, size, fraction ) ->
                return writeUInt( nil, number * pow2[ fraction ], size )

        }, true )

    -- signed byte
    registerIO( "b", {
        Size: ->
            return 1

        Read: ( _, str ) ->
            return byte( str, 1, 1 ) - 0x80

        Write: ( _, number ) ->
            assert( isint( number ), "signed byte must be an integer" )
            assert( number > -129 and number < 128, "signed byte overflow" )
            return char( number + 0x80 )

        ReadBits: ( readBit, size ) ->
            return readUIntBits( readBit, size ) - ( pow2[ size ] * 0.5 )

        WriteBits: ( writeBit, data, size ) ->
            return writeUIntBits( writeBit, data + ( pow2[ size ] * 0.5 ), size )

    }, true )

    -- unsigned byte
    registerIO( "B", {
        Size: ->
            return 1

        Read: ( _, str ) ->
            return byte( str, 1, 1 )

        Write: ( _, number ) ->
            assert( isuint( number ), "unsigned byte must be an unsigned integer" )
            assert( number > 0 and number < 256, "unsigned byte overflow" )
            return char( number )

        ReadBits: readUIntBits
        WriteBits: writeUIntBits

    }, true )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/b.lua
    -- boolean
    registerIO( "o", {
        Read: ( _, buffer ) ->
            return match( buffer, "%Z" ) and true or false

        ReadBits: ( readBit, size ) ->
            number = 0
            for _ = 1, size
                number += readBit!

            return number > 0

        Write: ( _, data, size ) ->
            return writeUInt( nil, data and 1 or 0, size )

        WriteBits: ( writeBit, data, size ) ->
            for _ = 1, size
                writeBit( data and 1 or 0 )

    }, true )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/s.lua
    -- fixed length strings
    writeString = ( _, data, size ) ->
        length = len( data )

        size = size or length

        if size > length
            data ..= rep( "\0", size - length )

        return sub( data, 1, size )

    do

        readString = ( fileDescriptor, binary, size ) ->
            if binary
                assert( len( binary ) == size, "length of buffer does not match length of string format" )
                return binary

            return fileDescriptor\Read( size or "*a" )

        registerIO( "c", {
            Size: defaultSize
            Read: readString
            Write: writeString
        }, true )

        -- https://github.com/ToxicFrog/vstruct/blob/master/io/x.lua
        -- skip/pad
        do

            -- unlike the seek controls @+- or the alignment control a, x will never call
            -- seek, and instead uses write '\0' or read-and-ignore - this means it is
            -- safe to use on streams.

            registerIO( "x", {
                Read: ( fileDescriptor, binary, size ) ->
                    readString( fileDescriptor, binary, size )
                    return nil

                ReadBits: ( readBit, size ) ->
                    for _ = 1, size
                        readBit!

                Write: ( fileDescriptor, data, size, value ) ->
                    return rep( char( value or 0 ), size )

                WriteBits: ( writeBit, _, size, value = 0 ) ->
                    assert( value == 0 or value == 1, "value must be 0 or 1" )
                    for _ = 1, size
                        writeBit( value )

            } )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/c.lua
    -- counted strings
    registerIO( "s", {
        Size: ( size ) ->
            if size
                assert( isnumber( size ), "size must be a number" )
                assert( size ~= 0, "size must be greater than 0" )

            return nil

        Read: ( fileDescriptor, _, size = 1 ) ->
            -- assert( size, "size is required for counted strings" )
            length = readUInt( nil, fileDescriptor\Read( size ), size )
            if length == 0
                return ""

            return fileDescriptor\Read( length )

        Write: ( fileDescriptor, data, size ) ->
            return writeUInt( nil, len( data ), size or 1 ) .. writeString( nil, data )

    }, true )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/z.lua
    -- zero-terminated strings

    -- null terminated string
    -- w==nil is write string as is + termination
    -- w>0 is write exactly w bytes, truncating/padding and terminating

    registerIO( "z", {
        Size: ( size ) ->
            return tonumber( size )

        Read: ( fileDescriptor, str, size, csize = 1 ) ->
            null = rep( "\0", csize )

            -- read exactly that many characters, then strip the null termination
            if size
                str = readString( fileDescriptor, str, size )
                length = 0

                -- search the string for the null terminator. If charsize > 1, just
                -- finding nul isn't good enough - it needs to be aligned on a character
                -- boundary.

                repeat
                    length = find( str, null, length + 1, true )
                until length == nil or ( length - 1 ) % csize == 0

                return sub( str, 1, ( length or 0 ) - 1 )

            -- this is where it gets ugly: the size wasn't specified, so we need to
            -- read (csize) bytes at a time looking for the null terminator
            chars, length = {}, 0

            c = fileDescriptor\Read( csize )
            while c and c ~= null
                length += 1
                chars[ length ] = c
                c = fileDescriptor\Read( csize )

            return concat( chars, "", 1, length )

        White: ( _, str, size, csize = 1 ) ->
            size = size or len( str ) + csize

            assert( size % csize == 0, "string length is not a multiple of character size" )

            -- truncate to field size
            if len( str ) >= size
                str = sub( str, 1, size - csize )

            return writeString( nil, str .. rep( "\0", csize ), size )

    }, true )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/m.lua
    -- bitmasks
    readBitmask = ( _, binary, size ) ->
        size = size or len( binary )
        mask, length = {}, 0

        if endianness.value == "big"
            for index = size, 1, -1
                byte0 = byte( binary, index, index )
                for num = 1, 8
                    length += 1
                    mask[ length ] = mod2[ byte0 ] == 1
                    byte0 = floor( byte0 / 2 )

            return mask

        for index = 1, size, 1
            byte0 = byte( binary, index, index )
            for num = 1, 8
                length += 1
                mask[ length ] = mod2[ byte0 ] == 1
                byte0 = floor( byte0 / 2 )

        return mask

    writeBitmask = ( _, bits, size ) ->
        buffer, length = {}, 0

        if endianness.value == "big"
            for index = size * 8, 1, -8
                length += 1
                buffer[ length ] = implode( bits, 8, index - 1 )

            return writeString( nil, char( unpack( buffer, 1, length ) ), size )

        for index = 1, size * 8, 8
            length += 1
            buffer[ length ] = implode( bits, 8, index - 1 )

        return writeString( nil, char( unpack( buffer, 1, length ) ), size )

    registerIO( "m", {
        Read: readBitmask
        ReadBits: ( readBit, size ) ->
            mask = {}
            for index = 1, size
                mask[ index ] = readBit! == 1

            return mask

        Write: writeBitmask
        WriteBits: ( writeBit, data, size ) ->
            for index = 1, size
                writeBit( data[ index ] and 1 or 0 )

    }, true )

    -- https://github.com/ToxicFrog/vstruct/blob/master/io/f.lua
    -- IEEE floating point floats, doubles and quads
    do

        import inf, nan, isnegative, frexp, ldexp from math

        -- float
        do

            -- constants
            c0 = pow2[ 7 ]
            c1 = pow2[ 8 ] - 1
            c2 = pow2[ 23 ]
            c3 = 1 - 23 - c0
            c4 = pow2[ 22 ]
            bias = c0 - 1
            c5 = bias + 1
            c6 = pow2[ 24 ]

            registerIO( "f", {
                Size: ->
                    return 4

                Read: ( _, binary ) ->
                    bits = readBitmask( nil, binary, 4 )
                    fraction = implode( bits, 23 )
                    exponent = implode( bits, 8, 23 )
                    sign = bits[ 32 ] and -1 or 1

                    if exponent == c1
                        if fraction == 0 or sign == -1
                            return sign * inf

                        return nan

                    if exponent ~= 0
                        fraction += c2
                    else
                        exponent = 1

                    return sign * ldexp( fraction, exponent + c3 )

                Write: ( _, float ) ->
                    local sign
                    if isnegative( float )
                        sign = true
                        float = -float
                    else
                        sign = false

                    local exponent, fraction

                    if float == inf
                        exponent = c5
                        fraction = 0

                    elseif float ~= float
                        exponent = c5
                        fraction = c4

                    elseif float == 0
                        exponent = -bias
                        fraction = 0

                    else
                        fraction, exponent = frexp( float )

                        ebs = exponent + bias
                        if ebs <= 1
                            fraction *= pow2[ 22 + ebs ]
                            exponent = -bias

                        else
                            fraction -= 0.5
                            exponent -= 1

                            fraction *= c6

                    bits = explode( fraction )
                    exponentBits = explode( exponent + bias )

                    for index = 1, 8
                        bits[ 23 + index ] = exponentBits[ index ]

                    bits[ 32 ] = sign

                    return writeBitmask( nil, bits, 4 )

            }, true )

        -- double
        do

            -- constants
            c0 = pow2[ 11 ] - 1
            c1 = pow2[ 52 ]
            c2 = pow2[ 10 ]
            c3 = 1 - 52 - c2
            c4 = pow2[ 51 ]
            bias = c2 - 1
            c5 = bias + 1
            c6 = pow2[ 53 ]

            registerIO( "d", {
                Size: ->
                    return 8

                Read: ( _, binary ) ->
                    bits = readBitmask( nil, binary, 8 )
                    fraction = implode( bits, 52 )
                    exponent = implode( bits, 11, 52 )
                    sign = bits[ 32 ] and -1 or 1

                    if exponent == c0
                        if fraction == 0 or sign == -1
                            return sign * inf

                        return nan

                    if exponent ~= 0
                        fraction += c1
                    else
                        exponent = 1

                    return sign * ldexp( fraction, exponent + c3 )

                Write: ( _, float ) ->
                    local sign
                    if isnegative( float )
                        sign = true
                        float = -float
                    else
                        sign = false

                    local exponent, fraction

                    if float == inf
                        exponent = c5
                        fraction = 0

                    elseif float ~= float
                        exponent = c5
                        fraction = c4

                    elseif float == 0
                        exponent = -bias
                        fraction = 0

                    else
                        fraction, exponent = frexp( float )

                        ebs = exponent + bias
                        if ebs <= 1
                            fraction *= pow2[ 51 + ebs ]
                            exponent = -bias

                        else
                            fraction -= 0.5
                            exponent -= 1

                            fraction *= c6

                    bits = explode( fraction )
                    exponentBits = explode( exponent + bias )

                    for index = 1, 11
                        bits[ 52 + index ] = exponentBits[ index ]

                    bits[ 32 ] = sign

                    return writeBitmask( nil, bits, 8 )

            }, true )

            setAlias( "d", "n" )

        -- quad
        do

            -- constants
            c0 = pow2[ 14 ]
            c1 = pow2[ 15 ] - 1
            c2 = pow2[ 111 ]
            c3 = pow2[ 112 ]
            c4 = 1 - 112 - c0
            bias = c0 - 1
            c5 = bias + 1
            c6 = pow2[ 113 ]

            registerIO( "q", {
                Size: ->
                    return 16

                Read: ( _, binary ) ->
                    bits = readBitmask( nil, binary, 16 )
                    fraction = implode( bits, 112 )
                    exponent = implode( bits, 15, 112 )
                    sign = bits[ 32 ] and -1 or 1

                    if exponent == c1
                        if fraction == 0 or sign == -1
                            return sign * inf

                        return nan

                    if exponent ~= 0
                        fraction += c3
                    else
                        exponent = 1

                    return sign * ldexp( fraction, exponent + c4 )

                Write: ( _, float ) ->
                    local sign
                    if isnegative( float )
                        sign = true
                        float = -float
                    else
                        sign = false

                    local exponent, fraction

                    if float == inf
                        exponent = c5
                        fraction = 0

                    elseif float ~= float
                        exponent = c5
                        fraction = c2

                    elseif float == 0
                        exponent = -bias
                        fraction = 0

                    else
                        fraction, exponent = frexp( float )

                        ebs = exponent + bias
                        if ebs <= 1
                            fraction *= pow2[ 111 + ebs ]
                            exponent = -bias

                        else
                            fraction -= 0.5
                            exponent -= 1

                            fraction *= c6

                    bits = explode( fraction )
                    exponentBits = explode( exponent + bias )

                    for index = 1, 15
                        bits[ 112 + index ] = exponentBits[ index ]

                    bits[ 32 ] = sign

                    return writeBitmask( nil, bits, 16 )

            }, true )

-- https://github.com/ToxicFrog/vstruct/blob/master/lexer.lua
do

    lexis, length = {}, 0

    addLexer = _module_0.AddLexer = ( name, pattern ) ->
        length += 1
        lexis[ length ] = { :name, pattern: "^" .. pattern }

    addLexer( false, "%s+" )                -- whitespace
    addLexer( false, "%-%-[^\n]*" )         -- comments
    addLexer( "key", "([%a_][%w_.]*):" )
    addLexer( "io", "([-+@<>=])" )
    addLexer( "io", "([%a_]+)" )
    addLexer( "number", "([%d.,]+)" )       -- may be multiple comma-separated numbers
    addLexer( "number", "(#[%a_][%w_.]*)" )
    addLexer( "splice", "&(%S+)" )
    addLexer( "{", "%{" )
    addLexer( "}", "%}" )
    addLexer( "(", "%(" )
    addLexer( ")", "%)" )
    addLexer( "*", "%*" )
    addLexer( "[", "%[" )
    addLexer( "]", "%]" )
    addLexer( "|", "%|" )

    _module_0.lexer = ( source ) ->
        index, hadWhitespace = 1, false

        where = ->
            return format( "character %d ('%s')", index, sub( source, 1, 4 ) )

        find_match = ->
            for index = 1, length
                data = lexis[ index ]
                if match( source, data.pattern )
                    _, endPos, text = find( source, data.pattern )
                    return data, endPos, text

            error( format( "Lexical error in format string at %s.", where! ) )
            return nil

        eat_whitespace = ->
            aux = ->
                if #source == 0
                    return nil

                matched, size = find_match!
                if matched.name
                    return nil

                source = sub( source, size + 1, len( source ) )
                hadWhitespace = true
                index += size
                return aux!

            hadWhitespace = false
            return aux!

        whitespace = ->
            return hadWhitespace

        next = ->
            eat_whitespace!

            if #source == 0
                return {
                    text: nil,
                    type: "EOF"
                }

            data, size, text = find_match!
            source = sub( source, size + 1, len( source ) )
            index += size

            return { :text, type: data.name }

        peek = ->
            eat_whitespace!

            if #source == 0
                return {
                    text: nil,
                    type: "EOF"
                }

            data, _, text = find_match!
            return { :text, type: data.name }

        return { :next, :peek, :where, :whitespace, tokens: -> return next }

-- https://github.com/ToxicFrog/vstruct/blob/master/ast.lua
ast = _module_0.ast = {}

do

    import gmatch from string

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Node.lua
    nodeClass = luaClass( "Node", {
        new: =>
            @size = 0

        Append: ( node ) =>
            @[] = node
            @size += node.size or 0

        Read: ( fileDescriptor, data ) =>
            for child in *@
                child\Read( fileDescriptor, data )

        ReadBits: ( bits, data ) =>
            for child in *@
                child\ReadBits( bits, data )

        Write: ( fileDescriptor, context ) =>
            for child in *@
                child\Write( fileDescriptor, context )

        WriteBits: ( bits, context ) =>
            for child in *@
                child\WriteBits( bits, context )
    } )

    ast.Node = nodeClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/List.lua
    listClass = luaClass( "List", nil, nil, nodeClass )
    ast.List = listClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Table.lua
    local tableClass
    do

        import Read, ReadBits from nodeClass

        tableClass = luaClass( "Table", {
            Read: ( fileDescriptor ) =>
                tbl = {}
                Read( @, fileDescriptor, tbl )
                return tbl

            ReadBits: ( bits ) =>
                tbl = {}
                ReadBits( @, bits, tbl )
                return tbl

        }, nil, nodeClass )

        ast.Table = tableClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Number.lua
    -- A node that holds either a number, or a reference to an already-read, named field which contains a number.
    local numberClass
    do

        numberClass = luaClass( "Number", {
            new: ( text ) =>
                if match( text, "^#" )
                    @key = sub( text, 2, len( text ) )
                else
                    @value = assert( tonumber( text ), "numeric constant '" .. text .. "' is not a number" )

            -- This does not support the regular read/write interface; the only thing you
            -- can do with it is get its contained number.
            -- If it holds a backreference and data is nil -- which should happen only at
            -- compile time -- it returns true to indicate that it contains something but
            -- cannot resolve it yet. If it holds a backreference and data is not-nil but
            -- also does not contain an appropriate field, it throws.
            Get: ( data ) =>
                if value := @value
                    return value

                if data
                    :key = @
                    for name in gmatch( key, "([^%.]+)%." )
                        if data[ name ] == nil
                            break

                        data = data[ name ]

                    value = data[ match( key, "[^%.]+$" ) ]
                    assert( value ~= nil, "backreferenced field '" .. key .. "' has not been read yet" )
                    assert( isnumber( value ), "backreferenced field '" .. key .. "' is not a numeric type" )
                    return value

                return true

        }, nil, nodeClass )

    ast.Number = numberClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Root.lua
    local rootClass
    do

        import Host from endianness

        rootClass = luaClass( "Root", {
            new: ( children ) =>
                @[ 1 ] = children
                @size = children.size

            Read: ( fileDescriptor, data ) =>
                Host!
                @[1]\Read( fileDescriptor, data )
                return data

            Write: ( fileDescriptor, data ) =>
                Host!
                @[1]\Write( fileDescriptor, { :data, n: 1 } )
                return nil

        }, nil, nodeClass )

    ast.Root = rootClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Repeat.lua
    repeatClass = luaClass( "Repeat", {
        new: ( @count, @child ) =>
            if count.value and child.size
                @size = count\Get( nil ) * child.size
            else
                -- Child has runtime-deferred size, or count is a backreference
                @size = nil

        Read: ( fileDescriptor, data ) =>
            :child = @
            for _ = 1, @count\Get( data )
                child\Read( fileDescriptor, data )

        ReadBits: ( bits, data ) =>
            :child = @
            for _ = 1, @count\Get( data )
                child\ReadBits( bits, data )

        Write: ( fileDescriptor, data ) =>
            :child = @
            for _ = 1, @count\Get( data.data )
                child\Write( fileDescriptor, data )

        WriteBits: ( bits, data ) =>
            :child = @
            for _ = 1, @count\Get( data.data )
                child\WriteBits( bits, data )

    }, nil, nodeClass )

    ast.Repeat = repeatClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Name.lua
    local nameClass
    do

        import tostring from environment

        put = ( data, key, value ) ->
            if key
                for name in gmatch( key, "([^%.]+)%." )
                    data = data[ name ]
                    if data == nil
                        data = {}

                data[ match( key, "[^%.]+$" ) ] = value
                return nil

            data[] = value

        -- Return a new subcontext containing only the data referenced by the key.
        -- `parent` points to the parent context, so that backreferences can be resolved.
        get = ( context, key ) ->
            local value
            if key
                :data = context
                for name in gmatch( key, "([^%.]+)%." )
                    if data[ name ] == nil
                        break

                    data = data[ name ]

                value = data[ match( key, "[^%.]+$" ) ]
            else
                :n = context
                value = context.data[ n ]
                context.n = n + 1

            assert( value ~= nil, "bad input while writing: no value for key " .. tostring( key or context.n - 1 ) )
            return {
                parent: context
                data: value
                n: 1
            }

        nameClass = luaClass( "Name", {
            new: ( @key, @child ) =>
                @size = child.size

            Read: ( fileDescriptor, data ) =>
                return put( data, @key, @child\Read( fileDescriptor, data ) )

            ReadBits: ( bits, data ) =>
                return put( data, @key, @child\ReadBits( bits, data ) )

            Write: ( fileDescriptor, context ) =>
                @child\Write( fileDescriptor, get( context, @key ) )
                return nil

            WriteBits: ( bits, context ) =>
                @child\WriteBits( bits, get( context, @key ) )
                return nil

        }, nil, nodeClass )

    ast.Name = nameClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/Bitpack.lua
    local bitpackClass
    do

        -- return an iterator over the individual bits in buffer
        biterator = ( binary ) ->
            data = { byte( binary, 1, len( binary ) ) }

            isBig = endianness.value == "big"
            index = isBig and 1 or #data
            delta = isBig and 1 or -1

            bit0 = 7

            return ->
                value = mod2[ floor( data[ index ] / pow2[ bit0 ] ) ]
                bit0 = ( bit0 - 1 ) % 8

                -- we just wrapped around
                if bit0 == 7
                    index += delta

                return value

        bitpacker = ( buffer, size ) ->
            for index = 1, size
                buffer[ index ] = 0

            isBig = endianness.value == "big"
            index = isBig and 1 or size
            delta = isBig and 1 or -1

            bit0 = 7

            return ( byte1 ) ->
                buffer[ index ] += byte1 * pow2[ bit0 ]
                bit0 = ( bit0 - 1 ) % 8

                -- we just wrapped around
                if bit0 == 7
                    index += delta

        bitpackClass = luaClass( "Bitpack", {
            new: ( size ) =>
                @size = 0
                @total_size = size

            Finalize: =>
                -- children are getting added with size in bits, not bytes
                :size = @
                size /= 8

                assert( size, "bitpacks cannot contain variable-width fields" )
                assert( size == @total_size, "bitpack contents do not match bitpack size: " .. size .. " ~= " .. @total_size )
                @size = size

            Read: ( fileDescriptor, data ) =>
                @ReadBits( biterator( fileDescriptor\Read( @size ) ), data )
                return nil

            Write: ( fileDescriptor, context ) =>
                buffer = {}
                @WriteBits( bitpacker( buffer, @size ), context )
                fileDescriptor\Write( char( unpack( buffer ) ) )

        }, nil, nodeClass )

    ast.Bitpack = bitpackClass

    -- https://github.com/ToxicFrog/vstruct/blob/master/ast/IO.lua
    ioClass = luaClass( "IO", {
        new: ( @name, args ) =>
            argv, n = { has_backrefs: false }, 0

            if args
                for arg in gmatch( args .. ",", "([^,]*)," )
                    n += 1

                    if arg == ""
                        argv[ n ] = nil

                    elseif number := tonumber( arg )
                        argv[ n ] = number

                    elseif match( arg, "^#[%a_][%w_.]*$" )
                        argv.has_backrefs = true
                        argv[ n ] = numberClass( arg )

                    else
                        argv[ n ] = arg

            @size = io[ name ].Size( argv[ 1 ] )
            @hasvalue = io[ name ].HasValue!
            @argv = argv
            argv.n = n

        Read: ( fileDescriptor, data ) =>
            local buffer

            :size = @
            if size and size > 0
                buffer = fileDescriptor\Read( size )
                assert( buffer and #buffer == size, "attempt to read past end of buffer in format " .. @name )

            return io[ @name ].Read( fileDescriptor, buffer, @GetArgv( data ) )

        ReadBits: ( bits, data ) =>
            return io[ @name ].ReadBits( bits, @GetArgv( data ) )

        Write: ( fileDescriptor, context ) =>
            buffer = io[ @name ].Write( fileDescriptor, context.data, @GetArgvContext( context ) )
            if buffer
                fileDescriptor\Write( buffer )

            return nil

        WriteBits: ( bits, context ) =>
            buffer = io[ @name ].WriteBits( bits, context.data, @GetArgvContext( context ) )
            if buffer
                fileDescriptor\Write( buffer )

            return nil

        GetArgv: ( data ) =>
            :argv = @
            :n = argv

            -- If backreferences were involved, we have to try to resolve them.
            if argv.has_backrefs
                buffer = {}
                for index = 1, n
                    if argv[ index ]
                        buffer[ index ] = argv[ index ]\Get( data )

                return unpack( buffer, 1, n )

            -- Usually the contents were determined at compile-time and we can just unpack it as is.
            return unpack( argv, 1, n )

        -- Get fully resolved argv from a write context rather than from the actual data structure.
        GetArgvContext: ( context ) =>
            return @GetArgv( ( context.parent or context ).data )

    }, nil, nodeClass )

    ast.IO = ioClass

    local iterator
    do

        -- used by the rest of the parser to report syntax errors
        ast_error = ast.error = ( lex, expected ) ->
            error( "parsing format string at " .. lex.where! .. ": expected " .. expected .. ", got " .. lex.peek!.type )
            return nil

        ast_require = ast.require = ( lex, typeName ) ->
            tbl = lex.next!
            if tbl.type ~= typeName
                ast_error( lex, typeName )

            return tbl

        local ast_next

        ast_next_until = ast.next_until = ( lex, typeName ) ->
            return ->
                tokType = lex.peek!.type
                if tokType == 'EOF'
                    ast_error( lex, typeName )
                    return nil

                if tokType == typeName
                    return nil

                return ast_next( lex )

        ast_repetition = ast.repetition = ( lex ) ->
            count = numberClass( lex.next!.text )
            ast_require( lex, "*" )
            return repeatClass( count, ast_next( lex ) )

        ast_group = ast.group = ( lex ) ->
            ast_require( lex, "(" )

            group = listClass!
            group.tag = "group"

            for value in ast_next_until( lex, ")" )
                group\Append( value )

            ast_require( lex, ")" )
            return group

        local ast_table, ast_io, ast_key
        do

            ast_raw_table = ast.raw_table = ( lex ) ->
                ast_require( lex, "{" )

                group = tableClass!

                for value in ast_next_until( lex, "}" )
                    group\Append( value )

                ast_require( lex, "}" )
                return group

            ast_table = ast.table = ( lex ) ->
                return nameClass( nil, ast_raw_table( lex ) )

            ast_raw_io = ast.raw_io = ( lex ) ->
                name = lex.next!.text
                value = lex.peek!

                if value and value.type == "number" and not lex.whitespace!
                    return ioClass( name, lex.next!.text )

                return ioClass( name, nil )

            ast_io = ast.io = ( lex ) ->
                value = ast_raw_io( lex )
                if value.hasvalue
                    return nameClass( nil, value )

                return value

            ast_key = ast.key = ( lex ) ->
                name = lex.next!.text

                switch lex.peek!.type
                    when "io"
                        value = ast_raw_io( lex )
                        if value.hasvalue
                            return nameClass( name, value )

                        ast_error( lex, "value (io specifier or table) - format '" .. name .. "' has no value" )
                        return nil

                    when "{"
                        return nameClass( name, ast_raw_table( lex ) )

                ast_error( lex, "value (io specifier or table)" )
                return nil

        ast_bitpack = ast.bitpack = ( lex ) ->
            ast_require( lex, "[" )

            bitpack = bitpackClass( tonumber( ast_require( lex, "number" ).text ) )
            ast_require( lex, "|" )

            for value in ast_next_until( lex, "]" )
                bitpack\Append( value )

            ast_require( lex, "]" )
            bitpack\Finalize!
            return bitpack

        ast_control = ast.control = ( lex ) ->
            name = lex.next!.text
            ast_require( lex, ":" )
            return nameClass( name, ast_next( lex ) )

        ast_splice = ast.splice = ( lex ) ->
            name = lex.next!.text

            root = registry[ name ]
            if root
                return root[ 1 ]

            error( "attempt to splice in format '" .. name .. "', which is not registered" )
            return nil

        ast_next = ast.next = ( lex ) ->
            tok = lex.peek!

            typeName = tok.type
            if typeName == "EOF"
                return nil

            if typeName == "("
                return ast_group( lex )

            if typeName == "{"
                return ast_table( lex )

            if typeName == "["
                return ast_bitpack( lex )

            if typeName == "io"
                return ast_io( lex )

            if typeName == "key"
                return ast_key( lex )

            if typeName == "number"
                return ast_repetition( lex )

            if typeName == "control"
                return ast_control( lex )

            if typeName == "splice"
                return ast_splice( lex )

            ast_error( lex, "'(', '{', '[', name, number, control, or io specifier" )
            return nil

        iterator = ast.iterator = ( lex ) ->
            return ->
                return ast_next( lex )

    do

        import lexer from _module_0

        ast.parse = ( source ) ->
            root = listClass!

            for node in iterator( lexer( source ) )
                root\Append( node )

            return rootClass( root )

-- https://github.com/ToxicFrog/vstruct/blob/master/api.lua
api = _module_0.api = {}
do

    local wrapFileDescriptor
    do

        import isfile from environment
        import Cursor from _module_0

        wrapFileDescriptor = api.WarpFileDescriptor = ( fileDescriptor ) ->
            if isstring( fileDescriptor )
                return Cursor( fileDescriptor )

            if isfile( fileDescriptor )
                return Cursor( fileDescriptor\Read!, fileDescriptor\Close! )

            return fileDescriptor

    import IsCursor from _module_0

    unwrapFileDescriptor = api.UnwrapFileDescriptor = ( fileDescriptor ) ->
        if IsCursor( fileDescriptor )
            fileDescriptor\Flush!
            return fileDescriptor.data

        return fileDescriptor

    api.Read = ( obj, fileDescriptor, data ) ->
        fileDescriptor = wrapFileDescriptor( fileDescriptor or "" )
        unless IsCursor( fileDescriptor )
            error "bad argument #2 to 'Read' (file or string expected, got " .. type( fileDescriptor ) .. ")", 3

        if data ~= nil
            ArgAssert( data, 3, "table" )

        return obj.ast\Read( fileDescriptor, data or {} )

    api.Write = ( obj, fileDescriptor, data ) ->
        if fileDescriptor and not data
            data, fileDescriptor = fileDescriptor, nil

        fileDescriptor = wrapFileDescriptor( fileDescriptor or "" )

        unless IsCursor( fileDescriptor )
            error "bad argument #2 to 'Write' (file or string expected, got " .. type( fileDescriptor ) .. ")", 3

        ArgAssert( data, 3, "table" )

        obj.ast\Write( fileDescriptor, data )
        return unwrapFileDescriptor( fileDescriptor )

    api.Records = ( ast, fileDescriptor, unpacked ) ->
        fileDescriptor = wrapFileDescriptor( fileDescriptor or "" )

        unless IsCursor( fileDescriptor )
            error "bad argument #2 to 'Records' (file or string expected, got " .. type( fileDescriptor ) .. ")", 3

        if unpacked ~= nil
            ArgAssert( unpacked, 3, "boolean" )

        return ->
            if fileDescriptor\Read( 0 )
                if unpacked
                    return unpack( ast\Read( fileDescriptor ) )

                return ast\Read( fileDescriptor )

    api.SizeOf = ( obj ) ->
        return obj.ast.size

    do

        import parse from ast

        cache = {}

        api.Compile = ( name, format ) ->
            local obj, root

            obj = cache[ format ]
            if obj
                root = obj.ast
            else
                root = parse( format )

                obj = {
                    ast: root
                    source: format
                    Read: api.Read
                    Write: api.Write
                    Records: api.Records
                    SizeOf: api.SizeOf
                }

                cache[ format ] = obj

            if name
                registry[ name ] = root

            return obj

-- https://github.com/ToxicFrog/vstruct/blob/master/init.lua
local read, write, sizeOf
do

    local records
    do

        import Compile, WarpFileDescriptor from api

        read = _module_0.Read = ( fmt, ... ) ->
            ArgAssert( fmt, 1, "string" )
            return Compile( nil, fmt )\Read( ... )

        write = _module_0.Write = ( fmt, ... ) ->
            ArgAssert( fmt, 1, "string" )
            return Compile( nil, fmt )\Write( ... )

        sizeOf = _module_0.SizeOf = ( fmt ) ->
            ArgAssert( fmt, 1, "string" )
            return Compile( nil, fmt ).ast.size

        _module_0.ReadVals = ( ... ) ->
            return unpack( read( ... ) )

        _module_0.Compile = ( name, fmt ) ->
            ArgAssert( name, 1, "string" )

            if fmt
                ArgAssert( fmt, 2, "string" )
                return Compile( name, fmt )

            return Compile( nil, name )

        records = _module_0.Records = ( fmt, fileDescriptor, unpacked ) ->
            ArgAssert( fmt, 1, "string" )

            if unpacked ~= nil
                ArgAssert( unpacked, 3, "boolean" )

            return Compile( nil, fmt )\Records( WarpFileDescriptor( fileDescriptor ), unpacked )

    _module_0.Array = ( fmt, fileDescriptor, length = 1 ) ->
        array = {}
        for record in records( fmt, fileDescriptor )
            array[ length ] = record
            length += 1

        return array

return _module_0
