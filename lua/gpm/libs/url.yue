--[[
    MIT License

    Copyright (c) 2024 Pika Software

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
--]]
import string, table, Error, TypeError, RangeError from gpm.environment
import byte, char, sub, gsub, match, find, lower, FastSplit from string
import istable, isnumber, isstring, tostring, tonumber, rawget, rawset, getmetatable from _G
import concat, insert, remove from table

CERTAINLY_NOT_NESTED = false
MIGHT_BE_NESTED = true

COMMA = 0x2C -- ,
EQUALS = 0x3D -- =
PCT = 0x25 -- %
LEFT = 0x5B -- [
RIGHT = 0x5D -- ]
AMP = 0x26 -- &
PLUS = 0x2B -- +
INT_START = 0x30 -- 0
INT_END = 0x39 -- 10

makeAsciiTable = (spec) ->
    ret = {}
    for item in *spec
        if isnumber(item)
            ret[item] = true
        else
            for j = item[1], item[2]
                ret[j] = true

    return ret

containsCharacter = (str, char1, fromIndex, stopCharacterTable) ->
    for i = fromIndex, #str
        ch = byte(str, i)
        if ch == char1
            return true

        if stopCharacterTable[ch]
            return false

    return false

containsCharacter2 = (str, char1, char2) ->
    for i = 1, #str
        ch = byte(str, i)
        if ch == char1 or ch == char2
            return true

    return false

isSlash = (str, pos) ->
    ch = byte(str, pos)
    return ch == 0x2F --[['/']] or ch == 0x5C --[['\']]

-- Lookup table for decoding percent-encoded characters and encoding special characters
-- Using HEX_TABLE will result in a double speedup compared to using functions
HEX_TABLE = []
for i = 0x00, 0xFF
    hex = bit.tohex(i, 2)
    HEX_TABLE[hex] = char(i)
    HEX_TABLE[hex\upper!] = char(i)
    HEX_TABLE[char(i)] = "%" .. hex\upper!

-- Special characters
HEX_TABLE["\r\n"] = "\n"
HEX_TABLE[" "] = "+"
HEX_TABLE["-"] = "-"
HEX_TABLE["."] = "."
HEX_TABLE["_"] = "_"
HEX_TABLE["~"] = "~"
HEX_TABLE["!"] = "!"
HEX_TABLE["*"] = "*"
HEX_TABLE["'"] = "'"
HEX_TABLE["("] = "("
HEX_TABLE[")"] = ")"

export decodeURI = (s) ->
    s = gsub(s, "%%(%x%x)", HEX_TABLE) |> gsub("+", " ")
    return s

export encodeURI = (s) ->
    s = gsub(s, "%W", HEX_TABLE)
    return s

autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n",
    "\t", "{", "}", "|", "\\", "^", "`", "'"]

autoEscapeMap = []

for c in *autoEscape
    esc = encodeURI(c)
    if esc == c
        esc = "%" .. bit.tohex(byte(c), 2)\upper!

    autoEscapeMap[byte(c)] = esc

afterQueryAutoEscapeMap = []

for k, v in pairs(autoEscapeMap)
    afterQueryAutoEscapeMap[k] = v

autoEscapeMap[0x5C --[['\']]] = "/"

-- https://github.com/petkaantonov/querystringparser
export class QueryStringParser
    maxLength: 32768
    maxDepth: 4
    maxKeys: 256

    parse: (str) =>
        @containsSparse = false
        @cacheKey = ""
        @cacheVal = nil

        if isstring(str)
            if #str > @maxLength
                error RangeError "str is too large (QueryStringParser.maxLength=" .. @maxLength .. ")"

            return @parseString(str, false)
        elseif istable(str)
            error Error "not implemented"

        return {}

    stringify: (obj) =>
        unless istable(obj)
            error TypeError "obj must be a table"

        keyPrefix = ""
        cur = obj
        key = nil
        value = nil
        isArray = false -- please do not pass array as first argument :)
        stack = []
        stackLen = 0
        ret, length = {}, 0

        -- spooky spooky while true loop :)
        while true
            if isArray
                key += 1
                value = cur[key]
                unless value
                    key = nil
            else
                key, value = next(cur, key)

            if key != nil
                serializedKey = encodeURI( isArray and tostring(key - 1) or tostring(key) )
                if istable(value)
                    stack[stackLen + 1] = keyPrefix
                    stack[stackLen + 2] = cur
                    stack[stackLen + 3] = key
                    stack[stackLen + 4] = isArray
                    stackLen += 4

                    keyPrefix = keyPrefix == "" and serializedKey or keyPrefix .. "[" .. serializedKey .. "]"
                    isArray = value[1] and true or false -- usually this is enough to determine if table is an array
                    key = isArray and 0 or nil
                    cur = value
                else
                    serializedKey = keyPrefix == "" and serializedKey or keyPrefix .. "[" .. serializedKey .. "]"
                    length += 1
                    ret[length] = serializedKey .. "=" .. encodeURI(value)
            elseif stackLen != 0
                keyPrefix = stack[stackLen - 3]
                cur = stack[stackLen - 2]
                key = stack[stackLen - 1]
                isArray = stack[stackLen]
                stackLen -= 4
            else
                break

        return concat(ret, "&", 1, length)


    decode: (str, shouldDecode, containsPlus) =>
        unless shouldDecode
            return str

        if containsPlus
            str = gsub(str, "%+", " ")

        return decodeURI(str)

    maybeArrayIndex: (str, arrayLength) =>
        length = #str
        -- Empty string I.E. direct brackets [] means index will be .length
        if length == 0
            return arrayLength

        ch = byte(str, 1)

        -- "0" is only valid index if it's the only character in the string
        -- "00", "001", are not valid array indices
        if ch == INT_START
            return length > 1 and -1 or 1

        if INT_START <= ch and ch <= INT_END
            -- Single digit number 1-9
            if length == 1
                return ch - INT_START + 1
            elseif match(str, "^%d+$")
                return tonumber(str) + 1

        return -1

    getSlot: (dictonary, prevKey, curKey) =>
        unless dictonary[prevKey]
            dictonary[prevKey] = {}

        return dictonary[prevKey]

    placeNestedValue: (dictonary, key, value, i, prevKey, curKey) =>
        slot = @getSlot(dictonary, prevKey, curKey)
        index = @maybeArrayIndex(curKey, #slot)

        length = #key
        depth = 2
        maxDepth = @maxDepth
        start = -1

        while (i <= length)
            ch = byte(key, i)
            if ch == LEFT
                start = i + 1
            elseif ch == RIGHT and start != -1
                prevKey = curKey
                curKey = start == i and "" or sub(key, start, i - 1)
                start = -1
                depth += 1

                if depth > maxDepth
                    error RangeError "too deep (QueryStringParser.maxDepth=" .. maxDepth .. ")"

                slot = @getSlot(slot, prevKey, curKey)
                index = @maybeArrayIndex(curKey, #slot)

            i += 1

        if index != -1
            if value != ""
                nextIndex = #slot + 1
                if index == nextIndex
                    slot[nextIndex] = value
                else
                    @containsSparse = true
                    slot[index] = value
        else
            @insert(slot, curKey, value)

    insert: (dictonary, key, value) =>
        if prev := dictonary[key]
            if istable(prev)
                prev[] = value
                return prev

            new = [prev, value]
            dictonary[key] = new
            return new

        dictonary[key] = value

    push: (dictonary, key, value) =>
        if prev := dictonary[key]
            prev[] = value
            return prev

        new = {value}
        dictonary[key] = new
        return new

    maybePlaceNestedValue: (dictonary, key, value) =>
        len = #key
        if byte(key, len) != RIGHT
            @placeValue(dictonary, key, value, CERTAINLY_NOT_NESTED)
            return

        start = -1
        i = 1
        curKey = nil
        prevKey = nil

        while i <= len
            ch = byte(key, i)
            if ch == LEFT
                start = i + 1
                prevKey = sub(key, 1, i - 1)
            elseif ch == RIGHT
                if start == -1
                    @placeValue(dictonary, key, value, CERTAINLY_NOT_NESTED)
                    return

                curKey = start == i and "" or sub(key, start, i - 1)
                i += 1
                break

            i += 1

        if curKey == nil
            @placeValue(dictonary, key, value, CERTAINLY_NOT_NESTED)
            return

        if curKey == "" and value != "" and i == len
            if key == @cacheKey
                @cacheValue[] = value
            else
                @cacheKey = key
                @cacheValue = @push(dictonary, prevKey, value)
        else
            @placeNestedValue(dictonary, key, value, i, prevKey, curKey)

    placeValue: (dictonary, key, value, possiblyNested) =>
        if possiblyNested == MIGHT_BE_NESTED
            @maybePlaceNestedValue(dictonary, key, value)
            return

        if key == @cacheKey
            @cacheValue[] = value
            return

        if cache := @insert(dictonary, key, value)
            @cacheKey = key
            @cacheValue = cache

    compact: (obj) =>
        unless istable(obj)
            return obj

        if obj[1] -- probably an array
            ret, length = [], 0
            for _, v in pairs obj
                length += 1
                ret[length] = v

            return ret

        for k, v in pairs obj
            obj[k] = @compact(v)

        return obj


    parseString: (str, noDecode) =>
        keys = 0
        decodeKey = false
        decodeValue = false
        possiblyNested = CERTAINLY_NOT_NESTED
        len = #str
        i = 1
        dictonary = {}
        keyStart = 1
        keyEnd = 1
        valueStart = 1
        valueEnd = 1
        left = 0
        containsPlus = false

        while i <= len
            ch = byte(str, i)

            if ch == LEFT
                left += 1
            elseif left > 0 and ch == RIGHT
                possiblyNested = MIGHT_BE_NESTED
                left -= 1
            elseif left == 0 and ch == EQUALS
                keyEnd = i - 1
                valueEnd = valueStart = i + 1
                key = @decode(sub(str, keyStart, keyEnd), decodeKey, containsPlus)
                decodeKey = false

                for j = valueStart, len
                    ch = byte(str, j)

                    if (ch == PLUS or ch == PCT) and not noDecode
                        if ch == PLUS then containsPlus = true
                        decodeValue = true

                    if ch == AMP or j == len
                        valueEnd = j
                        i = j

                        if ch == AMP
                            valueEnd -= 1

                        value = sub(str, valueStart, valueEnd)
                        value = @decode(value, decodeValue, containsPlus)

                        -- Place value
                        @placeValue(dictonary, key, value, possiblyNested)

                        containsPlus = decodeValue = false
                        possiblyNested = CERTAINLY_NOT_NESTED

                        keyStart = j + 1
                        keys += 1

                        if (keys > @maxKeys)
                            error RangeError "too many keys (QueryStringParser.maxKeys=" .. @maxKeys .. ")"

                        break

            elseif (ch == PLUS or ch == PCT) and not noDecode
                if ch == PLUS then containsPlus = true
                decodeKey = true

            i += 1

        if keyStart < len
            key = @decode(sub(str, keyStart, len), decodeKey, containsPlus)
            @placeValue(dictonary, key, "", possiblyNested)

        if @containsSparse
            -- original developer once said
            -- This behavior is pretty stupid but what you gonna do
            @compact(dictonary)

        return dictonary

-- https://github.com/petkaantonov/urlparser
export class URL
    queryString: QueryStringParser!

    _protocolCharacters: makeAsciiTable([
        [0x61, 0x7A], -- a-z
        [0x41, 0x5A], -- A-Z
        0x2E --[['.']],
        0x2B --[['+']],
        0x2D --[['-']]
    ])

    _hostEndingCharacters: makeAsciiTable([
        0x23 --[['#']],
        0x3F --[['?']],
        0x2F --[['/']],
        0x5C --[['\']]
    ])

    -- If these characters end a host name, the path will not be prepended a /
    _noPrependSlashHostEnders: makeAsciiTable([ byte(s) for s in *[
        "<", ">", "'", "`", " ", "\r",
        "\n", "\t", "{", "}", "|",
        "^", "`", "\"", "%", ";"
    ] ])

    _autoEscapeCharacters: makeAsciiTable([ byte(s) for s in *autoEscape ])

    _autoEscapeMap: autoEscapeMap
    _afterQueryAutoEscapeMap: afterQueryAutoEscapeMap

    _specialSchemes:
        "ftp": 21
        "file": true -- file does not have a port, but is a special scheme
        "http": 80
        "https": 443
        "ws": 80
        "wss": 443

    new: =>
        -- For more efficient internal representation and laziness.
        -- The non-underscore versions of these properties are accessor functions
        -- defined on the prototype.
        @_protocol = nil
        @_href = ""
        @_port = -1
        @_query = nil

        -- Probably just should remove these properties
        @auth = nil
        @slashes = false
        @host = nil
        @hostname = nil
        @hash = nil
        @search = nil
        @pathname = nil

        @_prependSlash = false

    parse: (str, parseStringQuery, disableAutoEscapeChars) =>
        unless isstring(str)
            error TypeError "Parameter 'url' must be a string, not " .. type(str)

        startPos = 1
        endPos = #str

        -- Trim leading and trailing whitespaces
        while byte(str, startPos) <= 0x20 --[[ space ]] do startPos += 1
        while byte(str, endPos) <= 0x20 --[[ space ]] do endPos -= 1

        startPos = @_parseProtocol(str, startPos, endPos)

        -- If after protocol there is //, then we must parse the host
        hasFollowingSolidus = byte(str, startPos) == 0x2F and byte(str, startPos + 1) == 0x2F and byte(str, startPos + 2) != 0x2F -- '/'

        protocol = @_protocol
        isSpecial = protocol and @_specialSchemes[protocol]
        if (isSpecial and protocol != "file") or hasFollowingSolidus
            startPos = @_parseHost(str, startPos, endPos)

            if not @hostname and @slashes and isSpecial
                @hostname = @host = ""

        if startPos <= endPos
            ch = byte(str, startPos)
            if ch == 0x3F --[['?']]
                @_parseQuery(str, startPos, endPos, disableAutoEscapeChars)
            elseif ch == 0x23 --[['#']]
                @_parseHash(str, startPos, endPos, disableAutoEscapeChars)
            else
                @_parsePath(str, startPos, endPos, disableAutoEscapeChars)

        if not @pathname and @hostname and isSpecial
            @pathname = "/"

        if parseStringQuery
            search = @search
            unless search
                search = @search = ""

            if byte(search, 0) == 0x3F -- '?'
                search = sub(search, 2)

            -- TODO: This calls a setter function, there is no .query data property
            @query = @queryString\parse(search)

    resolve: (relative) =>
        return @resolveObject(URL.parse(relative, false, true))\format!

    _escapePathname: (pathname) =>
        return gsub(pathname, "[%?#]", HEX_TABLE)

    _escapeSearch: (search) =>
        return gsub(search, "#", HEX_TABLE)

    format: =>
        query = @query or ""
        if istable(query)
            query = @queryString\stringify(query)

        search = @search or ""
        if search == ""
            search = query != "" and ("?" .. query) or ""

        protocol = @_protocol or ""
        if protocol != "" and byte(protocol, -1) != 0x3A -- ':'
            protocol ..= ":"

        hostname = @hostname or ""
        port = @_port or ""
        host = false

        auth = @auth or ""
        if auth != ""
            auth = gsub(encodeURI(auth), "%%3A", ":") .. "@"

        if @host
            host = auth .. @host
        elseif hostname != ""
            ip6 = find(hostname, ":", 1, true)
            if ip6
                hostname = "[" .. hostname .. "]"

            host = auth .. hostname .. (port != "" and ":" .. port or "")

        slashes = @slashes or ((protocol == "" or @_specialSchemes[protocol]) and host != false)

        scheme = protocol
        if slashes
            scheme ..= "//"

        pathname = @pathname or ""
        if pathname != ""
            if slashes and byte(pathname, 1) != 0x2F -- '/'
                pathname = "/" .. pathname

            pathname = @_escapePathname(pathname)

        if search != ""
            if byte(search, 1) != 0x3F -- '?'
                search = "?" .. search

            search = @_escapeSearch(search)

        hash = @hash or ""
        if hash != "" and byte(hash, 1) != 0x23 -- '#'
            hash = "#" .. hash

        host or= "" -- if host is false, then it should be an empty string

        return scheme .. host .. pathname .. search .. hash

    resolveObject: (relative) =>
        if isstring(relative)
            relative = URL.parse(relative, false, true)

        -- if the relative url is empty, then there"s nothing left to do here.
        if relative.href == ""
            return URL! -- Just build an empty URL object

        result = @_clone!

        -- hash is always overridden, no matter what.
        -- even href="" will remove it.
        result.hash = relative.hash

        -- hrefs like //foo/bar always cut to the protocol.
        if relative.slashes and not relative._protocol
            relative\_copyPropsTo(result, true)

            if @_specialSchemes[result._protocol] and result.hostname and not result.pathname
                result.pathname = "/"

            result._href = ""
            return result

        if relative._protocol and relative._protocol != result._protocol
            -- if it"s a known url protocol, then changing
            -- the protocol does weird things
            -- first, if it"s not file:, then we MUST have a host,
            -- and if there was a path
            -- to begin with, then we MUST have a path.
            -- if it is file:, then the host is dropped,
            -- because that"s known to be hostless.
            -- anything else is assumed to be absolute.
            if @_specialSchemes[relative._protocol]
                relative\_copyPropsTo(result, false)
                result._href = ""
                return result

            result._protocol = relative._protocol

            if not relative.host and relative._protocol != "javascript"
                relPath = relative.pathname and FastSplit(relative.pathname, 0x2F --[[ / ]]) or []

                while #relPath != 0
                    host = remove(relPath, 1)
                    if host and host != ""
                        relative.host = host
                        break

                unless relative.host
                    relative.host = ""

                unless relative.hostname
                    relative.hostname = ""

                if relPath[1] != ""
                    insert(relPath, 1, "")

                if #relPath < 2
                    insert(relPath, 1, "")

                result.pathname = concat(relPath, "/")
            else
                result.pathname = relative.pathname

            result.search = relative.search
            result.host = relative.host or ""
            result.auth = relative.auth
            result.hostname = relative.hostname or result.hostname
            result._port = relative._port
            result.slashes = relative.slashes
            result._href = ""
            return result

        isSourceAbs = result.pathname and byte(result.pathname, 1) == 0x2F -- '/'
        isRelAbs = not not relative.host or relative.pathname and byte(relative.pathname, 1) == 0x2F -- '/'
        mustEndAbs = isRelAbs or isSourceAbs or (result.host and relative.pathname)
        removeAllDots = mustEndAbs

        srcPath = result.pathname and FastSplit(result.pathname, 0x2F --[[ / ]]) or []
        relPath = relative.pathname and FastSplit(relative.pathname, 0x2F --[[ / ]]) or []
        -- psychotic = result._protocol and not @_specialSchemes[result._protocol]

        -- if the url is a non-slashed url, then relative
        -- links like ../.. should be able
        -- to crawl up to the hostname, as well.  This is strange.
        -- result.protocol has already been set by now.
        -- Later on, put the first path part into the host field.
        -- if psychotic
        --     result.hostname = ""
        --     result._port = -1
        --     if result.host
        --         if srcPath[1] == ""
        --             srcPath[1] = result.host
        --         else
        --             insert(srcPath, 1, result.host)

        --     result.host = ""
        --     if relative._protocol
        --         relative.hostname = ""
        --         relative._port = -1

        --         if relative.host
        --             if relPath[1] == ""
        --                 relPath[1] = relative.host
        --             else
        --                 insert(relPath, 1, relative.host)

        --         relative.host = ""

        --     mustEndAbs = mustEndAbs and (relPath[1] == "" or srcPath[1] == "")

        if isRelAbs
            -- it's absolute.
            result.host = relative.host or result.host
            result.hostname = relative.hostname or result.hostname
            result.search = relative.search
            srcPath = relPath
            -- fall through to the dot-handling below.
        elseif #relPath != 0
            -- it's relative
            -- throw away the existing file, and take the new path instead.
            unless srcPath
                srcPath = {}

            srcPath[#srcPath] = nil

            length = #srcPath
            for i = 1, #relPath
                length += 1
                srcPath[length] = relPath[i]

            result.search = relative.search
        elseif relative.search
            -- just pull out the search.
            -- like href="?foo".
            -- Put this after the other two cases because it simplifies the booleans
            -- if psychotic
            --     result.hostname = result.host = remove(srcPath, 1)
            --     -- occationaly the auth can get stuck only in host
            --     -- this especialy happens in cases like
            --     -- url.resolveObject("mailto:local1@domain1", "local2@domain2")
            --     authInHost = (result.host and (find(result.host, "@", 1, true) or -1) > 0) and FastSplit(result.host, 0x40 --[[ @ ]]) or false
            --     if authInHost
            --         result.auth = authInHost[1]
            --         result.host = result.hostname = authInHost[2]

            result.search = relative.search
            result._href = ""
            return result

        -- TODO: Make this faster
        srcLength = #srcPath
        if srcLength == 0
            -- no path at all.  easy.
            -- we"ve already handled the other stuff above.
            result.pathname = nil
            result._href = ""
            return result

        -- if a url ENDs in . or .., then it must get a trailing slash.
        -- however, if it ends in anything else non-slashy,
        -- then it must NOT get a trailing slash.
        last = srcPath[srcLength]
        hasTrailingSlash = (result.host or relative.host) or (last == "." or last == ".." ) or last == ""

        -- strip single dots, resolve double dots to parent dir
        -- if the path tries to go above the root, `up` ends up > 0
        up = 0
        for i = srcLength, 1, -1
            last = srcPath[i]
            if last == "."
                remove(srcPath, i)
            elseif last == ".."
                remove(srcPath, i)
                up += 1
            elseif up > 0
                remove(srcPath, i)
                up -= 1

        -- if the path is allowed to go above the root, restore leading ..s
        if not mustEndAbs and not removeAllDots
            while up > 0
                insert(srcPath, 1, "..")
                up -= 1

        if mustEndAbs and srcPath[1] != "" and (not srcPath[1] or byte(srcPath[1], 1) != 0x2F --[['/']])
            insert(srcPath, 1, "")

        -- TODO: there ( in glua ) are no absolute paths and idk how fix this
        -- if hasTrailingSlash and byte( concat( srcPath, "/" ), 1 ) != 0x2F --[['/']]
        --     srcPath[] = ""

        -- isAbsolute = srcPath[1] == "" or (srcPath[1] and byte(srcPath[1], 1) == 0x2F --[['/']])
        isAbsolute = true

        -- put the host back
        -- if psychotic
        --     result.hostname = result.host = isAbsolute and "" or #srcPath > 0 and remove(srcPath, 1) or ""
        --     -- occationaly the auth can get stuck only in host
        --     -- this especialy happens in cases like
        --     -- url.resolveObject("mailto:local1@domain1", "local2@domain2")
        --     authInHost = result.host and (find(result.host, "@", 1, true) or -1) > 0 and FastSplit(result.host, 0x40 --[[ @ ]]) or false
        --     if authInHost
        --         result.auth = authInHost[1]
        --         result.host = result.hostname = authInHost[2]

        mustEndAbs = mustEndAbs or (result.host and #srcPath > 0)

        if not mustEndAbs and not isAbsolute
            insert(srcPath, 1, "")

        result.pathname = #srcPath != 0 and concat(srcPath, "/") or nil
        result.auth = relative.auth or result.auth
        result.slashes = result.slashes or relative.slashes
        result._href = ""
        return result


    _hostIdna: (hostname) =>
        -- TODO: Implement punycode and convert Idna to punycode
        return encodeURI(hostname)

    _parseProtocol: (str, startPos, endPos) =>
        doLowerCase = false
        protocolCharacters = @_protocolCharacters
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x3A --[[ : ]]
                protocol = sub(str, startPos, i - 1)
                if doLowerCase
                    protocol = lower(protocol)
                @_protocol = protocol
                return i + 1
            elseif protocolCharacters[ch]
                if ch < 0x61 --[[ a ]]
                    doLowerCase = true
            else
                break

        return startPos

    _parseAuth: (str, startPos, endPos, decode) =>
        auth = sub(str, startPos, endPos)
        if decode
            auth = decodeURI(auth)
        @auth = auth

    _parsePort: (str, startPos, endPos) =>
        -- Internal format is integer for more efficient parsing
        -- and for efficient trimming of leading zeros
        port = 0
        -- Distinguish between :0 and : (no port number at all)
        hadChars = false
        validPort = true
        i = startPos

        while i <= endPos
            ch = byte(str, i)
            if 0x30 <= ch --[['0']] and ch <= 0x39 -- [['9']]
                port = (10 * port) + (ch - 0x30 --[['0']])
                hadChars = true
            else
                validPort = false
                if ch == 0x5C --[['\']] or ch == 0x2F --[['/']]
                    validPort = true
                break
            i += 1

        if (port == 0 or not hadChars) or not validPort
            if not validPort
                @_port = -2
            return 0

        protocol = @_protocol
        unless protocol and @_specialSchemes[protocol] == port
            @_port = port
        return i - startPos

    _parseHost: (str, startPos, endPos) =>
        hostEndingCharacters = @_hostEndingCharacters
        first = byte(str, startPos)
        second = byte(str, startPos + 1)
        if (first == 0x2F --[[ / ]] or first == 0x5C --[[ \ ]]) and (second == 0x2F --[[ / ]] or second == 0x5C --[[ \ ]])
            @slashes = true

            -- The string starts with //
            if startPos == 0
                -- The string is just "//"
                if endPos < 2
                    return startPos

            startPos += 2
        -- If there is no slashes, there is no hostname if
        -- 1. there was no protocol at all
        -- 2. there was a protocol that requires slashes
        -- e.g. in 'http:asd' 'asd' is not a hostname
        elseif not @_protocol or @_specialSchemes[@_protocol]
            return startPos

        doLowerCase = true
        idna = false
        hostNameStart = startPos
        hostNameEnd = endPos
        lastCh = -1
        portLength = 0
        charsAfterDot = 0
        authNeedsDecoding = false
        j = -1

        -- Find the last occurrence of an @-sign until hostending character is met
        -- also mark if decoding is needed for the auth portion
        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x40 -- '@'
                j = i
            elseif ch == 0x25 -- '%'
                authNeedsDecoding = true
            elseif hostEndingCharacters[ch]
                break

        -- @-sign was found at index j, everything to the left from it is auth part
        if j > -1
            @_parseAuth(str, startPos, j - 1, authNeedsDecoding)
            startPos = hostNameStart = j + 1

        -- Host name is starting with a [
        if byte(str, startPos) == 0x5B -- '['
            for i = startPos + 1, endPos
                ch = byte(str, i)
                -- Assume valid IP6 is between the brackets
                if ch == 0x5D -- ']'
                    if byte(str, i + 1) == 0x3A -- ':'
                        portLength = @_parsePort(str, i + 2, endPos)

                    hostname = lower(sub(str, startPos + 1, i - 1))
                    @hostname = hostname
                    @host = @_port > 0 and ("[" .. hostname .. "]:" .. @_port) or ("[" .. hostname .. "]")
                    @pathname = "/"

                    return i + portLength + 1

            -- Empty hostname, [ starts a path
            return startPos

        for i = startPos, endPos
            if charsAfterDot > 62
                @hostname = @host = sub(str, startPos, i)
                return i

            ch = byte(str, i)
            if ch == 0x3A -- ':'
                portLength = @_parsePort(str, i + 1, endPos) + 1
                hostNameEnd = i - 1
                break
            elseif ch < 0x61 -- 'a'
                if ch == 0x2E -- '.'
                    charsAfterDot = -1
                elseif 0x41 --[['A']] <= ch and ch <= 0x5A --[['Z']]
                    doLowerCase = false
                -- Valid characters other than ASCII letters -, _, +, 0-9
                elseif not (ch == 0x2D --[['-']] or ch == 0x5F --[['_']] or ch == 0x2B --[['+']] or (0x30 --[['0']] <= ch and ch <= 0x39 --[['9']]))
                    unless hostEndingCharacters[ch] or @_noPrependSlashHostEnders[ch]
                        @_prependSlash = true

                    hostNameEnd = i - 1
                    break
            elseif ch >= 0x7B -- '{'
                if ch <= 0x7E -- '~'
                    unless @_noPrependSlashHostEnders[ch]
                        @_prependSlash = true

                    hostNameEnd = i - 1
                    break

                idna = true

            lastCh = ch
            charsAfterDot += 1

        if (hostNameEnd + 1) != startPos and (hostNameEnd - hostNameStart) <= 256
            hostname = sub(str, hostNameStart, hostNameEnd)
            if doLowerCase
                hostname = lower(hostname)
            if idna
                hostname = @_hostIdna(hostname)

            @hostname = hostname
            @host = @_port > 0 and (hostname .. ":" .. @_port) or hostname

        return hostNameEnd + 1 + portLength

    _copyPropsTo: (input, noProtocol) =>
        if not noProtocol
            input._protocol = @_protocol
        input._href = @_href
        input._port = @_port
        input._prependSlash = @_prependSlash
        input.auth = @auth
        input.slashes = @slashes
        input.host = @host
        input.hostname = @hostname
        input.hash = @hash
        input.search = @search
        input.pathname = @pathname

    _clone: =>
        url = URL!
        url._protocol = @_protocol
        url._href = @_href
        url._port = @_port
        url._prependSlash = @_prependSlash
        url.auth = @auth
        url.slashes = @slashes
        url.host = @host
        url.hostname = @hostname
        url.hash = @hash
        url.search = @search
        url.pathname = @pathname
        return url

    _getComponentEscaped: (str, startPos, endPos, isAfterQuery) =>
        cur = startPos
        i = startPos
        ret, length = [], 0
        autoEscapeMap = isAfterQuery and @_afterQueryAutoEscapeMap or @_autoEscapeMap

        while i <= endPos
            ch = byte(str, i)
            escaped = autoEscapeMap[ch]
            if escaped
                length += 1
                if cur < i
                    ret[length] = sub(str, cur, i - 1)

                ret[length] = escaped
                cur = i + 1

            i += 1

        if cur < i + 1
            length += 1
            ret[length] = sub(str, cur, i)

        return concat(ret, "", 1, length)

    _parsePath: (str, startPos, endPos, disableAutoEscapeChars) =>
        pathStart = startPos
        pathEnd = endPos
        escape = false
        autoEscapeCharacters = @_autoEscapeCharacters
        prePath = @_port == -2 and "/:" or ""

        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x23 -- '#'
                @_parseHash(str, i, endPos, disableAutoEscapeChars)
                pathEnd = i - 1
                break
            elseif ch == 0x3F -- '?'
                @_parseQuery(str, i, endPos, disableAutoEscapeChars)
                pathEnd = i - 1
                break
            elseif not disableAutoEscapeChars and not escape and autoEscapeCharacters[ch]
                escape = true

        if pathStart > pathEnd
            @pathname = prePath == "" and "/" or prePath
            return

        local path
        if escape
            path = @_getComponentEscaped(str, pathStart, pathEnd, false)
        else
            path = sub(str, pathStart, pathEnd)

        @pathname = prePath == "" and (@_prependSlash and "/" .. path or path) or (prePath .. path)

    _parseQuery: (str, startPos, endPos, disableAutoEscapeChars) =>
        queryStart = startPos
        queryEnd = endPos
        escape = false
        autoEscapeCharacters = @_autoEscapeCharacters

        for i = startPos, endPos
            ch = byte(str, i)
            if ch == 0x23 -- '#'
                @_parseHash(str, i, endPos, disableAutoEscapeChars)
                queryEnd = i - 1
                break
            elseif not disableAutoEscapeChars and not escape and autoEscapeCharacters[ch]
                escape = true

        if queryStart > queryEnd
            @search = ""
            return

        if escape
            @search = @_getComponentEscaped(str, queryStart, queryEnd, true)
        else
            @search = sub(str, queryStart, queryEnd)

    _parseHash: (str, startPos, endPos, disableAutoEscapeChars) =>
        if startPos > endPos
            @hash = ""
            return

        @hash = disableAutoEscapeChars and sub(str, startPos, endPos) or @_getComponentEscaped(str, startPos, endPos, false)

    -- properties
    __index: (key) =>
        return switch key
            when "port" then @getPort!
            when "query" then @getQuery!
            when "path" then @getPath!
            when "protocol" then @getProtocol!
            when "scheme" then @getScheme!
            when "href" then @getHref!
            else rawget(URL.__base, key)

    __newindex: (key, value) =>
        switch key
            when "port" then @setPort(value)
            when "query" then @setQuery(value)
            when "path" then @setPath(value)
            when "protocol" then @setProtocol(value)
            when "scheme" then @setProtocol(value)
            when "href" then @setHref(value)
            else rawset(@, key, value)

    -- port
    getPort: =>
        port = @_port
        if port >= 0
            return tostring( port )

    setPort: (value) =>
        if value == nil
            @_port = -1
        else
            @_port = tonumber( value )

    -- query
    getQuery: =>
        if query := @_query
            return query

        search = @search
        if search
            if byte(search, 1) == 0x3f -- '?'
                search = sub(search, 2)

            if search != ""
                @_query = search
                return search

        return search

    setQuery: (value) =>
        @_query = value

    -- path
    getPath: =>
        return (@pathname or "") .. (@search or "")

    setPath: -> -- Empty func

    -- protocol
    getProtocol: =>
        protocol = @_protocol or ""
        return protocol != "" and (protocol .. ":") or ""

    setProtocol: (value) =>
        if isstring(value)
            if byte(value, -1) == 0x3A -- ':'
                @_protocol = sub(value, 1, -2)
            else
                @_protocol = value
        elseif not value
            @_protocol = nil

    -- scheme
    getScheme: =>
        return @_protocol

    -- href
    getHref: =>
        href = @_href
        if not href or href == ""
            href = @_href = @format!

        return href

    setHref: (value) =>
        @_href = value

    @parse: (str, parseStringQuery, hostDenotesSlash, disableAutoEscapeChars) ->
        if istable(str) and str.__name == URL.__name
            return str

        url = URL!
        url\parse(str, not not parseStringQuery, not not hostDenotesSlash, not not disableAutoEscapeChars)
        return url

    @format: (obj) ->
        if isstring(obj)
            obj = URL.parse(obj)

        if not istable(obj) or obj.__name != URL.__name
            return URL.__base.format(obj)

        return obj\format!

    @resolve: (source, relative) ->
        return URL.parse(source)\resolve(relative)

    @resolveObject: (source, relative) ->
        if source
            return URL.parse(source, false, true)\resolveObject(relative)

        return relative

    @__base.setScheme = @__base.setProtocol
    @__base.__tostring = @__base.format

export IsQueryStringParser = ( any ) ->
    metatable = getmetatable( any )
    return metatable and metatable.__class == QueryStringParser

export IsURL = ( any ) ->
    metatable = getmetatable( any )
    return metatable and metatable.__class == URL
